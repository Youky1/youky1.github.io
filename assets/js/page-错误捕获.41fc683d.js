(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{601:function(e,a,s){"use strict";s.r(a);var t=s(1),r=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"错误捕获"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误捕获"}},[e._v("#")]),e._v(" 错误捕获")]),e._v(" "),a("p",[e._v("React 提供了两个 API 进行错误捕获：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("getDerivedStateFromError")])])]),e._v(" "),a("p",[e._v("静态方法，保存在 fiberNode.type 上。用于渲染 fallback UI，需要返回一个 state,")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("componentDidCatch")])])]),e._v(" "),a("p",[e._v("组件实例方法，保存在组件实例（fiber.stateNode）上。\n用于执行副作用代码（如上报等）")]),e._v(" "),a("p",[e._v("这两个方法只能在类组件中使用，只能捕获子组件中的错误（组件自身的不行），使用了这两个方法的组件成为错误边界（Error boundaries）。")]),e._v(" "),a("p",[e._v("捕获的过程分为三步：")]),e._v(" "),a("ol",[a("li",[e._v("捕获错误")]),e._v(" "),a("li",[e._v("构造 callback")]),e._v(" "),a("li",[e._v("执行 callback")])]),e._v(" "),a("h2",{attrs:{id:"捕获范围"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#捕获范围"}},[e._v("#")]),e._v(" 捕获范围")]),e._v(" "),a("p",[e._v("Error boundaries 捕获的是 render 阶段和 commit 阶段的错误")]),e._v(" "),a("p",[e._v("不会被捕获的四类错误：")]),e._v(" "),a("ul",[a("li",[e._v("回调函数中的错误")]),e._v(" "),a("li",[e._v("异步代码中的错误")]),e._v(" "),a("li",[e._v("SSR 中的错误")]),e._v(" "),a("li",[e._v("Error boundaries 组件中出现的错误")])]),e._v(" "),a("h2",{attrs:{id:"捕获错误"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#捕获错误"}},[e._v("#")]),e._v(" 捕获错误")]),e._v(" "),a("p",[e._v("根据当前流程的不同，会交由不同的回调函数处理。")]),e._v(" "),a("ul",[a("li",[e._v("render 阶段："),a("code",[e._v("handleError")])]),e._v(" "),a("li",[e._v("commit 阶段："),a("code",[e._v("captureCommitPhaseError")])])]),e._v(" "),a("p",[e._v("然后都会交给 "),a("code",[e._v("captureCommitPhaseError")]),e._v(" 方法处理")]),e._v(" "),a("h2",{attrs:{id:"构造-callback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造-callback"}},[e._v("#")]),e._v(" 构造 callback")]),e._v(" "),a("p",[e._v("从发生异常的 fiberNode 的父节点开始，向上寻找 Error boundaries。")]),e._v(" "),a("ul",[a("li",[e._v("若找到，会执行 "),a("code",[e._v("createClassErrorUpdate")]),e._v(" 方法构造 update 对象，它的属性是待执行的回调\n"),a("ul",[a("li",[e._v("payload：执行 "),a("code",[e._v("getDerivedStateFromError")])]),e._v(" "),a("li",[e._v("callback：抛出 React 提示信息，执行 "),a("code",[e._v("componentDidCatch")])])])]),e._v(" "),a("li",[e._v("若没有找到，会构造 callback，内部抛出“未捕获的错误”以及 React 提示信息")])]),e._v(" "),a("h2",{attrs:{id:"执行-callback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行-callback"}},[e._v("#")]),e._v(" 执行 callback")]),e._v(" "),a("h3",{attrs:{id:"render-阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-阶段"}},[e._v("#")]),e._v(" render 阶段")]),e._v(" "),a("p",[a("code",[e._v("handleError")]),e._v(" 会将 相关信息交给 "),a("code",[e._v("throwException")]),e._v(" 方法处理")]),e._v(" "),a("p",[e._v("首先判断是否是 Promise 类型（Suspense wakeable Error），并根据结果做不同处理")]),e._v(" "),a("blockquote",[a("p",[e._v("TODO: Suspense wakeable 是什么？")])]),e._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n  value "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!==")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&&")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("typeof")]),e._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("===")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"object"')]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&&")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("typeof")]),e._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("then "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("===")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"function"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 处理 suspense 场景")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("else")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("h4",{attrs:{id:"suspense-wakeable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#suspense-wakeable"}},[e._v("#")]),e._v(" Suspense wakeable")]),e._v(" "),a("ul",[a("li",[e._v("首先会重置 Suspense 的状态，将其 state 恢复到本次渲染之前。")]),e._v(" "),a("li",[e._v("通过 "),a("code",[e._v("getSuspenseHandler")]),e._v(" 返回寻找 suspense 的错误边界 fiber")]),e._v(" "),a("li",[e._v("如果找到，判断当前元素是否是离屏元素，如果是离屏元素则只在 concurrent 模式才处理，sync 模式不处理。\n"),a("ul",[a("li",[e._v("添加重新渲染的监听：将捕获到的 Promise 加入 fiber 节点的 "),a("code",[e._v("updateQueue")]),e._v("。如果后续这个 Promise 变为 resolve，则会重新渲染 Suspense")])])]),e._v(" "),a("li",[e._v("如果找不到，判断是否是同步更新\n"),a("ul",[a("li",[e._v("如果是同步更新，属于异常，会抛出一个 Error")]),e._v(" "),a("li",[e._v("如果不是同步更新，则也会添加重新渲染的监听")])])])]),e._v(" "),a("h4",{attrs:{id:"非-suspense-wakeable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非-suspense-wakeable"}},[e._v("#")]),e._v(" 非 Suspense wakeable")]),e._v(" "),a("p",[e._v("构造出的 update 对象，会交由 "),a("code",[e._v("enqueueCapturedUpdate")]),e._v(" 处理，将 "),a("code",[e._v("update")]),e._v(" 添加到 fiber 对应的 "),a("code",[e._v("updateQueue")]),e._v(" 中")]),e._v(" "),a("p",[e._v("如果 commit")]),e._v(" "),a("p",[e._v("执行 callback 的时机有两个")])])}),[],!1,null,null,null);a.default=r.exports}}]);