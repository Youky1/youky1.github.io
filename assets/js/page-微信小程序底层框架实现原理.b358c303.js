(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{627:function(a,t,v){"use strict";v.r(t);var e=v(1),_=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"微信小程序底层框架实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微信小程序底层框架实现原理"}},[a._v("#")]),a._v(" 微信小程序底层框架实现原理")]),a._v(" "),t("h2",{attrs:{id:"双线程架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双线程架构"}},[a._v("#")]),a._v(" 双线程架构")]),a._v(" "),t("h3",{attrs:{id:"是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[a._v("#")]),a._v(" 是什么？")]),a._v(" "),t("p",[a._v("渲染层与逻辑层分别由两个线程管理，两个线程之间由 Native 层进行统一处理")]),a._v(" "),t("ul",[t("li",[a._v("渲染层的界面使用 webview 进行渲染。\n"),t("ul",[t("li",[a._v("多个页面对应多个 webview（最多 10 个）")])])]),a._v(" "),t("li",[a._v("逻辑层采用 JSCore 运行 JavaScript 代码\n"),t("ul",[t("li",[a._v("只有一个 APP 实例，所有 JS 都在一个线程中执行")])])])]),a._v(" "),t("h3",{attrs:{id:"对比单线程的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比单线程的优势"}},[a._v("#")]),a._v(" 对比单线程的优势")]),a._v(" "),t("ul",[t("li",[a._v("避免单线程中，由于资源加载而阻塞页面解析")]),a._v(" "),t("li",[a._v("将微信 SDK、底层基础库等放在 Native 层中，减少应用的包体积和网络请求数量")])]),a._v(" "),t("h3",{attrs:{id:"如何解决-h5-的安全问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何解决-h5-的安全问题"}},[a._v("#")]),a._v(" 如何解决 H5 的安全问题")]),a._v(" "),t("ul",[t("li",[a._v("禁用部分 JS 操作：如获取 DOM、动态执行 JS 代码等")]),a._v(" "),t("li",[a._v("为 JS 提供沙箱环境")])]),a._v(" "),t("h3",{attrs:{id:"为什么需要提供-wxs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要提供-wxs"}},[a._v("#")]),a._v(" 为什么需要提供 WXS")]),a._v(" "),t("p",[a._v("双线程架构中，频繁的跨线程通信（如手势识别等）会带来性能问题。")]),a._v(" "),t("p",[a._v("WXS 可以"),t("strong",[a._v("在渲染层中")]),a._v("写部分逻辑，在渲染层单独处理部分频繁改变的数据")]),a._v(" "),t("h2",{attrs:{id:"pageframe"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pageframe"}},[a._v("#")]),a._v(" PageFrame")]),a._v(" "),t("h3",{attrs:{id:"解决的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决的问题"}},[a._v("#")]),a._v(" 解决的问题")]),a._v(" "),t("p",[a._v("每个页面都是一个独立的 webview，其中包含大量内容。小程序如何快速新建并打开页面")]),a._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),t("p",[a._v("作为一个"),t("strong",[a._v("模板")]),a._v("，其中引用了各种通用资源 js，当多次使用 PageFrame 创建页面时，这些自资源会使用本地缓存。")]),a._v(" "),t("p",[a._v("启动一个页面的步骤：")]),a._v(" "),t("ol",[t("li",[a._v("启动一个 webview")]),a._v(" "),t("li",[a._v("在其中初始化基础库，以及一些基础库的内部优化")]),a._v(" "),t("li",[a._v("注入 WXML 和 WXSS，小程序能在接收到页面初始数据之后马上开始渲染")])]),a._v(" "),t("h2",{attrs:{id:"exparser"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#exparser"}},[a._v("#")]),a._v(" Exparser")]),a._v(" "),t("p",[a._v("Exparser 是小程序的"),t("strong",[a._v("组件组织框架")]),a._v("，基本参考 Shadow DOM 模型实现。")]),a._v(" "),t("p",[a._v("Shadow DOM 是 WebComponents 中的概念，它允许将隐藏的 DOM 结构附加到常规的 DOM 树中。可以选择外界是否能获取内部结构。")]),a._v(" "),t("p",[a._v("一些 HTML 标签是浏览器内置的 ShadowDOM 组件，如 video、button 等。这些组件不能作为 ShadowDOM 的宿主元素。")]),a._v(" "),t("p",[a._v("Shadow DOM 中的事件，可以选择是否冒泡至宿主元素外部")]),a._v(" "),t("h2",{attrs:{id:"wxss"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#wxss"}},[a._v("#")]),a._v(" WXSS")]),a._v(" "),t("h3",{attrs:{id:"和-css-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#和-css-的区别"}},[a._v("#")]),a._v(" 和 css 的区别")]),a._v(" "),t("ul",[t("li",[a._v("新增了 rpx 单位，换算方式为屏幕宽度为 "),t("code",[a._v("375px")]),a._v(" 时，"),t("code",[a._v("1px = 2rpx")])]),a._v(" "),t("li",[a._v("仅支持部分选择器")])]),a._v(" "),t("h3",{attrs:{id:"编译方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译方式"}},[a._v("#")]),a._v(" 编译方式")]),a._v(" "),t("p",[a._v("WXSS 文件不在 webview 中渲染，而是提前编译为 js。\n在该 js 中，会获取设备信息（屏幕宽度等），并以此将 rpx 转换为实际像素。\n该 js 内容会通过 eval 进行执行，并最终生成 style 标签插入到页面中。")]),a._v(" "),t("h2",{attrs:{id:"wxml-的编译-virtual-dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#wxml-的编译-virtual-dom"}},[a._v("#")]),a._v(" WXML 的编译：Virtual DOM")]),a._v(" "),t("p",[a._v("WXML 代码也会编译为 JS，生成一个 "),t("code",[a._v("$gwx")]),a._v(" 函数，它用于生成虚拟 DOM。")]),a._v(" "),t("p",[t("code",[a._v("$gwx")]),a._v(" 的返回值也是一个函数 "),t("code",[a._v("generateFun")]),a._v("， "),t("code",[a._v("generateFun")]),a._v(" 接受模板渲染所需的动态数据，其返回值是虚拟 DOM 树。")]),a._v(" "),t("h2",{attrs:{id:"事件通讯系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件通讯系统"}},[a._v("#")]),a._v(" 事件通讯系统")]),a._v(" "),t("h3",{attrs:{id:"通信机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通信机制"}},[a._v("#")]),a._v(" 通信机制")]),a._v(" "),t("ul",[t("li",[a._v("渲染层和逻辑层的通信都是通过 Native 层转发\n"),t("ul",[t("li",[a._v("iOS 是利用了 WKWebView 的提供 messageHandlers 特性")]),a._v(" "),t("li",[a._v("安卓是往 WebView 的 window 对象注入一个原生方法")])])]),a._v(" "),t("li",[a._v("在微信中封装为 "),t("code",[a._v("WeiXinJSBridge")]),a._v(" 作为兼容层")]),a._v(" "),t("li",[a._v("在开发者工具中则是用 Websocket 对通信方法进行模拟")])]),a._v(" "),t("h3",{attrs:{id:"绑定事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#绑定事件"}},[a._v("#")]),a._v(" 绑定事件")]),a._v(" "),t("p",[a._v("标签的所有 attribute 都会存在虚拟 DOM 的 attr 属性中，通过正则判断某个属性是否是绑定的事件，找出事件后为节点注册事件。")]),a._v(" "),t("p",[a._v("小程序的事件都是和 HTML 原生事件对应的（如 tap 对应 mouseup），最终会通过 "),t("code",[a._v("window.addEventListener")]),a._v(" 添加原生事件的监听")]),a._v(" "),t("h3",{attrs:{id:"触发事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发事件"}},[a._v("#")]),a._v(" 触发事件")]),a._v(" "),t("p",[a._v("渲染层中，会拼接事件的 event 参数，创建一个 exparser 事件并触发，通过 sendData 向逻辑层通信")]),a._v(" "),t("h3",{attrs:{id:"数据在两个线程中的传递"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据在两个线程中的传递"}},[a._v("#")]),a._v(" 数据在两个线程中的传递")]),a._v(" "),t("p",[a._v("页面加载时，data 中的数据会以 JSON 字符串的形式传至渲染层。因此，"),t("strong",[a._v("data 中的数据必须是可以转为 JSON 的类型")])]),a._v(" "),t("blockquote",[t("p",[a._v("字符串，数字，布尔值，对象，数组")])]),a._v(" "),t("h2",{attrs:{id:"小程序框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小程序框架"}},[a._v("#")]),a._v(" 小程序框架")]),a._v(" "),t("h3",{attrs:{id:"预编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预编译"}},[a._v("#")]),a._v(" 预编译")]),a._v(" "),t("p",[a._v("自己定义一套 DSL（语法规则），一般对应 React 或 Vue，通过源码的 AST 解析还原为微信小程序原生代码的形式")]),a._v(" "),t("p",[a._v("局限性：")]),a._v(" "),t("ul",[t("li",[a._v("React 或 Vue 出了新的语法，要兼容的话要扩展 DSL")]),a._v(" "),t("li",[a._v("兼容问题，小程序不支持的属性，无法编译")])]),a._v(" "),t("h3",{attrs:{id:"半编译半运行时-mpvue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#半编译半运行时-mpvue"}},[a._v("#")]),a._v(" 半编译半运行时：mpvue")]),a._v(" "),t("p",[a._v("基于类 vue 语法")]),a._v(" "),t("ul",[t("li",[a._v("将 template 编译为 wxml")]),a._v(" "),t("li",[a._v("在 vue 的 patch 流程中，不更新 DOM，而是触发 "),t("code",[a._v("setData")]),a._v(" 来更新视图")])]),a._v(" "),t("h3",{attrs:{id:"纯运行时框架-remax"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#纯运行时框架-remax"}},[a._v("#")]),a._v(" 纯运行时框架：remax")]),a._v(" "),t("h4",{attrs:{id:"纯运行时框架要解决的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#纯运行时框架要解决的问题"}},[a._v("#")]),a._v(" 纯运行时框架要解决的问题")]),a._v(" "),t("p",[a._v("React / Vue 的视图更新都是基于 "),t("strong",[a._v("DOM API")]),a._v(" 的，但小程序的逻辑层并未提供任何操作节点的 API。")]),a._v(" "),t("p",[a._v("唯一的更新视图的方式，就是 "),t("code",[a._v("setData")]),a._v("。")]),a._v(" "),t("h4",{attrs:{id:"解决思路-动态-template"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决思路-动态-template"}},[a._v("#")]),a._v(" 解决思路：动态 template")]),a._v(" "),t("p",[a._v("WXML 提供"),t("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/template.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("模板（template）"),t("OutboundLink")],1),a._v("，可以在模板中定义代码片段，然后在不同的地方调用。")]),a._v(" "),t("p",[a._v("使用模板时，通过 "),t("code",[a._v("is")]),a._v(" 属性决定要使用的模板是哪一个。而 "),t("code",[a._v("is")]),a._v(" 属性的取值可以用双括号语法从而使用 data 中的数据。")]),a._v(" "),t("p",[a._v("因此，实现的思路就是：")]),a._v(" "),t("ul",[t("li",[a._v("在 data 中实现一个类似虚拟 DOM 的对象，通过递归的形式在 WXML 中将其渲染为 template")]),a._v(" "),t("li",[a._v("更新 DOM 的流程，改为更改这个虚拟 DOM 对象，通过 setData 触发视图更新")])])])}),[],!1,null,null,null);t.default=_.exports}}]);