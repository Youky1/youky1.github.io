(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{610:function(t,c,e){"use strict";e.r(c);var o=e(1),a=Object(o.a)({},(function(){var t=this,c=t._self._c;return c("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[c("h1",{attrs:{id:"watch和computed的区别"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#watch和computed的区别"}},[t._v("#")]),t._v(" watch和computed的区别")]),t._v(" "),c("ul",[c("li",[t._v("computed是计算出一个新的属性并挂载到vue实例。watch是监听已存在的属性，所以watch同样可以监听computed计算出的属性")]),t._v(" "),c("li",[t._v("computed是"),c("strong",[t._v("惰性的")]),t._v("，"),c("strong",[t._v("只有当这个计算属性被实际使用时才会进行计算")]),t._v("。否则即使其依赖的值发生了改变，也不会执行")]),t._v(" "),c("li",[t._v("watch中可以执行异步操作，而computed中不可以（因为要返回一个值，无法等待异步操作完成）")]),t._v(" "),c("li",[t._v("使用场景上的不同：computed适用于依赖多个值进行计算；watch适用于当值发生改变时执行某些操作")])])])}),[],!1,null,null,null);c.default=a.exports}}]);