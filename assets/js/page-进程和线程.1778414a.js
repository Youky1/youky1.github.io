(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{647:function(t,v,_){"use strict";_.r(v);var a=_(1),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"进程和线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程"}},[t._v("#")]),t._v(" 进程和线程")]),t._v(" "),v("h2",{attrs:{id:"并发和并行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发和并行"}},[t._v("#")]),t._v(" 并发和并行")]),t._v(" "),v("ul",[v("li",[t._v("并发是指宏观上多个任务同时运行，实际上是交替运行的")]),t._v(" "),v("li",[t._v("并行是指多CPU的情况下，多个线程微观上同时运行")])]),t._v(" "),v("h2",{attrs:{id:"进程和线程的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的区别"}},[t._v("#")]),t._v(" 进程和线程的区别")]),t._v(" "),v("ul",[v("li",[t._v("地址空间角度：一个进程内至少要有一个线程，多个线程可以共享进程的地址空间，而进程间的地址空间是独立的")]),t._v(" "),v("li",[t._v("进程是"),v("strong",[t._v("资源分配的基本单位")]),t._v("，同一个进程内的线程共享进程的资源")]),t._v(" "),v("li",[t._v("线程是"),v("strong",[t._v("处理器调度的基本单位")])])]),t._v(" "),v("h3",{attrs:{id:"为什么需要线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要线程"}},[t._v("#")]),t._v(" 为什么需要线程")]),t._v(" "),v("p",[t._v("进程切换的开销很大：")]),t._v(" "),v("ul",[v("li",[t._v("处理机的上下文切换")]),t._v(" "),v("li",[t._v("与进程相关的数据结构的改变，如页表、各种队列等")])]),t._v(" "),v("p",[t._v("因此引入了线程：一个进程分为的多个执行任务的单元体，只为其分配处理机。线程的切换只需切换必须的与处理机相关的信息，减少了开销。")]),t._v(" "),v("h2",{attrs:{id:"进程的状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程的状态"}},[t._v("#")]),t._v(" 进程的状态")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("就绪")]),t._v("：一个进程获得了处理机以外的所有资源，得到处理机即可运行的状态")]),t._v(" "),v("li",[v("strong",[t._v("运行")]),t._v("：正在处理机上运行")]),t._v(" "),v("li",[v("strong",[t._v("阻塞")]),t._v("：也称为等待状态，进程在等待某件事发生（如等待IO完成）而暂时停止运行")])]),t._v(" "),v("h2",{attrs:{id:"进程间通信ipc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信ipc"}},[t._v("#")]),t._v(" 进程间通信IPC")]),t._v(" "),v("h3",{attrs:{id:"信号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号"}},[t._v("#")]),t._v(" 信号")]),t._v(" "),v("p",[t._v("是一种“"),v("strong",[t._v("发布-订阅")]),t._v("”的模式，由操作系统事先定义，接收到该信号的进程可以采取自定义的响应行为")]),t._v(" "),v("h3",{attrs:{id:"信号量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[t._v("#")]),t._v(" 信号量")]),t._v(" "),v("p",[t._v("信号量是一种特殊的变量，对它的操作通过PV原语，P表示减少，V表示增加")]),t._v(" "),v("h3",{attrs:{id:"管道"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#管道"}},[t._v("#")]),t._v(" 管道")]),t._v(" "),v("p",[t._v("管道是一种半双工通信方式，如在Linux中用管道操作符"),v("code",[t._v("|")]),t._v("表示两个两个命令之间的数据通信，前一个命令的标准输出会作为下一个命令的标准输入")]),t._v(" "),v("h3",{attrs:{id:"共享内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[t._v("#")]),t._v(" 共享内存")]),t._v(" "),v("p",[t._v("允许不同进程共享一段物理内存，进程将该段共享内存映射到自己的地址空间，然后像访问普通内存一样对其进行访问。")]),t._v(" "),v("p",[t._v("不同进程通过向共享内存读写数据来交换信息。")]),t._v(" "),v("ul",[v("li",[t._v("优点：简单高效。")]),t._v(" "),v("li",[t._v("缺点：存在并发问题")])]),t._v(" "),v("h3",{attrs:{id:"消息队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),v("ul",[v("li",[t._v("是一个消息的链表，保存在内核中")]),t._v(" "),v("li",[t._v("提供了有格式的数据")]),t._v(" "),v("li",[t._v("是异步的，接收者必须通过轮询消息队列，才能收到消息")])]),t._v(" "),v("h3",{attrs:{id:"套接字socket"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#套接字socket"}},[t._v("#")]),t._v(" 套接字Socket")]),t._v(" "),v("ul",[v("li",[t._v("Socket可以用于不同计算机的进程之间，也可以用于同一台计算机的不同进程之间")]),t._v(" "),v("li",[t._v("进行通信的进程首先各自创建一个socket，包含主机号和端口号，声明自己接受来自某端口地址的数据")]),t._v(" "),v("li",[t._v("进程通过socket把消息发送到网络层，网络层通过主机地址将其发送到目的主机，目的主机通过端口号将消息发送到目的进程")])])])}),[],!1,null,null,null);v.default=s.exports}}]);