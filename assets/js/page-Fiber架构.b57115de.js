(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{597:function(e,r,t){"use strict";t.r(r);var i=t(1),o=Object(i.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"fiber-架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber-架构"}},[e._v("#")]),e._v(" Fiber 架构")]),e._v(" "),r("h2",{attrs:{id:"fiber-的三层含义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber-的三层含义"}},[e._v("#")]),e._v(" Fiber 的三层含义")]),e._v(" "),r("ol",[r("li",[e._v("作为一种架构")])]),e._v(" "),r("p",[e._v("v16 版本的 reconciler 采用基于 Fiber 的可中断实现，称为 Fiber Reconciler 替代了此前的递归实现。\n当每一个 Fiber 对应的更新工作完成后，会查询浏览器是否属于空闲状态，如果有则继续执行，如果没有则中断，等待下一次浏览器空闲，以达到可中断更新。")]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[e._v("作为一种数据结构")])]),e._v(" "),r("p",[e._v("每个 FiberNode 对应一个 React 元素，用于保存这个元素的信息\nFiber 树和组件树基本一一对应（有些元素没有对应的 Fiber，如文本节点、Fragment）")]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[e._v("作为一种工作单元")])]),e._v(" "),r("p",[e._v("每个 FiberNode 用于保存本次更新中该 React 元素"),r("strong",[e._v("变化的数据")]),e._v("，"),r("strong",[e._v("要执行的工作")]),e._v("，如：")]),e._v(" "),r("ul",[r("li",[e._v("flags：表示要执行的操作类型")]),e._v(" "),r("li",[e._v("lanes：调度优先级")]),e._v(" "),r("li",[e._v("alternate：指向双缓存机制下的另一颗 Fiber tree 中对应的节点")])]),e._v(" "),r("h2",{attrs:{id:"双缓存机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双缓存机制"}},[e._v("#")]),e._v(" 双缓存机制")]),e._v(" "),r("p",[e._v("Fiber 架构中，会同时存在两颗 Fiber Tree，一个是当前 UI 对应的，一个是正在内存中构建的（wait in process，简称 wip），二者之间通过 alternate 指向彼此。")]),e._v(" "),r("h2",{attrs:{id:"mount-时的-fiber-构建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mount-时的-fiber-构建"}},[e._v("#")]),e._v(" Mount 时的 Fiber 构建")]),e._v(" "),r("p",[e._v("mount 代表首次挂载，此时流程如下：")]),e._v(" "),r("h3",{attrs:{id:"_1-创建-fiberrootnode"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建-fiberrootnode"}},[e._v("#")]),e._v(" 1. 创建 "),r("code",[e._v("FiberRootNode")])]),e._v(" "),r("p",[e._v("负责管理应用的全局状态，如双 Fiber 树的切换，任务的过期、调度信息。")]),e._v(" "),r("p",[e._v("mount 时是只有跟节点的空白页面。此时当前 Fiber 树只有一个"),r("code",[e._v("HostRootFiber")])]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("FiberRootNode.current = HostRootFiber\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("h3",{attrs:{id:"_2-创建-hostrootfiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-创建-hostrootfiber"}},[e._v("#")]),e._v(" 2. 创建 "),r("code",[e._v("HostRootFiber")])]),e._v(" "),r("p",[r("code",[e._v("HostRoot")]),e._v(" 代表应用在宿主环境挂载的根节点，"),r("code",[e._v("HostRootFiber")]),e._v(" 即 "),r("code",[e._v("HostRoot")]),e._v("对应的 Fiber")]),e._v(" "),r("h3",{attrs:{id:"_3-dfs-生成-fiber-树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-dfs-生成-fiber-树"}},[e._v("#")]),e._v(" 3. DFS 生成 FIber 树")]),e._v(" "),r("p",[e._v("从 "),r("code",[e._v("HostRootFiber")]),e._v(" 开始，DFS 生成 wip Fiber 树。这个过程中，会为每个 FiberNode 标记 flags，代表其不同的副作用（DOM 的增删改）。")]),e._v(" "),r("p",[e._v("生成 wip Fiber 树的过程会复用当前 Fiber 树，mount 时只有 "),r("code",[e._v("HostRootFiber")]),e._v(" 可复用。")]),e._v(" "),r("p",[e._v("当 wip Fiber 树构建完成，会交给 renderer 进行渲染。当渲染完成后 wip 会成为当前的 Fiber 树。 FiberRootNode.current 随之切换")]),e._v(" "),r("h2",{attrs:{id:"update-时的-fiber-构建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#update-时的-fiber-构建"}},[e._v("#")]),e._v(" Update 时的 Fiber 构建")]),e._v(" "),r("p",[e._v("与 mount 基本一致，区别在于：")]),e._v(" "),r("ul",[r("li",[e._v("不会再创建 "),r("code",[e._v("FiberRootNode")])]),e._v(" "),r("li",[e._v("wip Fiber 树会复用当前 Fiber 树")])])])}),[],!1,null,null,null);r.default=o.exports}}]);