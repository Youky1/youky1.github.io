(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{678:function(_,v,a){"use strict";a.r(v);var t=a(1),s=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"https的流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https的流程"}},[_._v("#")]),_._v(" HTTPS的流程")]),_._v(" "),v("h2",{attrs:{id:"_1-客户端发起请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-客户端发起请求"}},[_._v("#")]),_._v(" 1. 客户端发起请求")]),_._v(" "),v("p",[_._v("请求的开头，当然就是客户端发起HTTPS请求，默认发送到服务端的"),v("code",[_._v("443")]),_._v("端口")]),_._v(" "),v("h2",{attrs:{id:"_2-服务端提供配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-服务端提供配置"}},[_._v("#")]),_._v(" 2. 服务端提供配置")]),_._v(" "),v("p",[_._v("要提供HTTPS服务，服务端需要向"),v("strong",[_._v("CA机构")]),_._v("申请"),v("strong",[_._v("数字证书")]),_._v("。")]),_._v(" "),v("p",[_._v("证书内容包括：")]),_._v(" "),v("ul",[v("li",[_._v("证书持有者信息")]),_._v(" "),v("li",[_._v("网站的信息（域名等）")]),_._v(" "),v("li",[_._v("公钥信息")])]),_._v(" "),v("p",[_._v("为了防止数据在传送过程中被中间人掉包，CA机构会对证书制作数字签名：")]),_._v(" "),v("ol",[v("li",[_._v("对明文数据"),v("strong",[_._v("data")]),_._v("进行hash，得到哈希值（进行hash的目的：数据量很大，而hash值是固定的128位）")]),_._v(" "),v("li",[_._v("用私钥对哈希值进行加密，得到签名"),v("strong",[_._v("S")])]),_._v(" "),v("li",[_._v("明文数据data和签名S共同组成了"),v("strong",[_._v("数字证书")])])]),_._v(" "),v("h2",{attrs:{id:"_3-返回证书"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-返回证书"}},[_._v("#")]),_._v(" 3. 返回证书")]),_._v(" "),v("p",[_._v("服务端向客户端返回证书，其中包含了非对称加密的公钥。")]),_._v(" "),v("p",[_._v("在接收到证书后，客户端要验证其真实性：")]),_._v(" "),v("ol",[v("li",[_._v("得到证书，拿到明文数据data，签名S")]),_._v(" "),v("li",[_._v("用公钥对S进行解密，得到S'")]),_._v(" "),v("li",[_._v("对data进行hash，得到data'")]),_._v(" "),v("li",[_._v("若data' == S'则数据未被更改")])]),_._v(" "),v("p",[_._v("同时，由于证书中包含了网站信息，客户端可以得知证书是否被中间人掉包。")]),_._v(" "),v("h2",{attrs:{id:"_4-生成对称秘钥"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-生成对称秘钥"}},[_._v("#")]),_._v(" 4. 生成对称秘钥")]),_._v(" "),v("p",[_._v("客户端生成一个随机数X，作为后续对称加密的秘钥。")]),_._v(" "),v("p",[_._v("用证书中的公钥进行加密后，传递给服务端")]),_._v(" "),v("h2",{attrs:{id:"_5-服务端得到对称秘钥"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-服务端得到对称秘钥"}},[_._v("#")]),_._v(" 5. 服务端得到对称秘钥")]),_._v(" "),v("p",[_._v("服务端接收到加密后的秘钥后，用自己的私钥进行解密。")]),_._v(" "),v("p",[_._v("至此双方都得到了一个对称加密的秘钥X，后续内容都通过X进行对称加密即可")]),_._v(" "),v("h2",{attrs:{id:"对于过程的疑问"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对于过程的疑问"}},[_._v("#")]),_._v(" 对于过程的疑问")]),_._v(" "),v("h3",{attrs:{id:"为什么要使用对称加密而不是直接使用非对称加密"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用对称加密而不是直接使用非对称加密"}},[_._v("#")]),_._v(" 为什么要使用对称加密而不是直接使用非对称加密")]),_._v(" "),v("p",[_._v("性能问题。对称加密的性能要好很多")]),_._v(" "),v("h3",{attrs:{id:"中间人可以篡改证书吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#中间人可以篡改证书吗"}},[_._v("#")]),_._v(" 中间人可以篡改证书吗")]),_._v(" "),v("p",[_._v("不能。如果篡改了证书的明文数据，中间人能得到新的hash值。")]),_._v(" "),v("p",[_._v("但是由于没有网站的私钥，无法修改数字签名，因此会被客户端发现信息被篡改。")]),_._v(" "),v("h3",{attrs:{id:"中间人可以直接掉包证书吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#中间人可以直接掉包证书吗"}},[_._v("#")]),_._v(" 中间人可以直接掉包证书吗")]),_._v(" "),v("p",[_._v("不能。证书中包含了网站的信息，如果证书被掉包，客户端会发现与自己请求的域名不同")]),_._v(" "),v("h3",{attrs:{id:"每次请求都要在ssl层进行握手传输秘钥吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#每次请求都要在ssl层进行握手传输秘钥吗"}},[_._v("#")]),_._v(" 每次请求都要在SSL层进行握手传输秘钥吗")]),_._v(" "),v("p",[_._v("不需要。")]),_._v(" "),v("p",[_._v("服务器会为每个客户端维护一个"),v("code",[_._v("session ID")]),_._v("，并传递给浏览器。")]),_._v(" "),v("p",[_._v("在浏览器传递来"),v("code",[_._v("对称秘钥")]),_._v("时，服务器会把该秘钥存到相应的"),v("code",[_._v("session ID")]),_._v("下。")]),_._v(" "),v("p",[_._v("之后的请求中，浏览器会携带"),v("code",[_._v("session ID")]),_._v("，服务端即可找到相应的"),v("code",[_._v("对称秘钥")])])])}),[],!1,null,null,null);v.default=s.exports}}]);